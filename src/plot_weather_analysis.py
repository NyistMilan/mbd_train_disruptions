"""
Plot Weather-Delay Analysis Results

This script creates visualizations from the aggregated data generated by
analyze_weather_delays.py (PySpark). Run this locally after downloading
the CSV files from HDFS.

Usage:
    1. Download results from HDFS:
       hdfs dfs -get /user/s3544648/final_project/data/analysis ./analysis_data
    
    2. Run this script:
       python src/plot_weather_analysis.py
"""

import os
from pathlib import Path
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Configuration
DATA_DIR = Path("./analysis_data")  # Downloaded from HDFS
OUTPUT_DIR = Path("./analysis_output")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

plt.style.use('seaborn-v0_8-whitegrid')
plt.rcParams['figure.figsize'] = (12, 6)
plt.rcParams['font.size'] = 11


def load_csv_from_spark_output(folder_path: Path) -> pd.DataFrame:
    """Load CSV from Spark output folder (handles part-* files)."""
    if not folder_path.exists():
        print(f"Warning: {folder_path} does not exist")
        return None
    
    # Find the CSV file (Spark outputs as part-*.csv)
    csv_files = list(folder_path.glob("part-*.csv"))
    if not csv_files:
        csv_files = list(folder_path.glob("*.csv"))
    
    if not csv_files:
        print(f"Warning: No CSV files found in {folder_path}")
        return None
    
    return pd.read_csv(csv_files[0])


def plot_correlation_heatmap(corr_df: pd.DataFrame, output_dir: Path):
    """Create a heatmap of weather-delay correlations."""
    if corr_df is None or corr_df.empty:
        print("No correlation data available")
        return
    
    print("Creating correlation heatmap...")
    
    # Pivot for heatmap
    pivot = corr_df.pivot_table(
        index='weather_variable',
        columns='delay_variable',
        values='correlation'
    )
    
    fig, ax = plt.subplots(figsize=(10, 8))
    sns.heatmap(
        pivot, 
        annot=True, 
        cmap='RdBu_r', 
        center=0,
        fmt='.3f',
        vmin=-0.3,
        vmax=0.3,
        ax=ax,
        linewidths=0.5
    )
    ax.set_title('Weather-Delay Correlations\n(Pearson r)', fontsize=14, fontweight='bold')
    ax.set_xlabel('Delay Variable', fontsize=12)
    ax.set_ylabel('Weather Variable', fontsize=12)
    
    plt.tight_layout()
    plt.savefig(output_dir / 'correlation_heatmap.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_dir / 'correlation_heatmap.png'}")


def plot_correlation_bar(corr_df: pd.DataFrame, output_dir: Path):
    """Create a bar chart of correlations for arrival delay."""
    if corr_df is None or corr_df.empty:
        print("No correlation data available")
        return
    
    print("Creating correlation bar chart...")
    
    # Filter for arrival delay only
    arrival_corr = corr_df[corr_df['delay_variable'] == 'stop_arrival_delay'].copy()
    arrival_corr = arrival_corr.sort_values('correlation')
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    colors = ['red' if x > 0 else 'blue' for x in arrival_corr['correlation']]
    bars = ax.barh(arrival_corr['weather_label'], arrival_corr['correlation'], color=colors, alpha=0.7)
    
    ax.axvline(x=0, color='black', linewidth=0.5)
    ax.set_xlabel('Pearson Correlation Coefficient (r)', fontsize=12)
    ax.set_title('Weather Variables Correlation with Arrival Delay', fontsize=14, fontweight='bold')
    
    # Add correlation values on bars
    for bar, val in zip(bars, arrival_corr['correlation']):
        x_pos = val + 0.005 if val >= 0 else val - 0.005
        ha = 'left' if val >= 0 else 'right'
        ax.text(x_pos, bar.get_y() + bar.get_height()/2, f'{val:.3f}', 
                va='center', ha=ha, fontsize=9)
    
    plt.tight_layout()
    plt.savefig(output_dir / 'correlation_bar.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_dir / 'correlation_bar.png'}")


def plot_delay_by_category(delay_stats: dict, output_dir: Path):
    """Create bar plots showing delay rates by weather category."""
    print("Creating delay by category plots...")
    
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    
    categories = [
        ('temperature', 'Temperature', 'temp_category'),
        ('wind', 'Wind Speed', 'wind_category'),
        ('precipitation', 'Precipitation', 'rain_category')
    ]
    
    for ax, (key, title, col) in zip(axes, categories):
        if key in delay_stats and delay_stats[key] is not None:
            data = delay_stats[key]
            if data.empty:
                continue
            
            x = range(len(data))
            bars = ax.bar(x, data['mean_delay'], color='steelblue', alpha=0.7)
            
            ax.set_xticks(x)
            ax.set_xticklabels(data[col] if col in data.columns else data.iloc[:, 0], 
                             rotation=45, ha='right')
            ax.set_xlabel(title)
            ax.set_ylabel('Mean Arrival Delay (minutes)')
            ax.set_title(f'Delay by {title}')
            
            # Add count annotations
            for i, (_, row) in enumerate(data.iterrows()):
                ax.annotate(f'n={int(row["count"]):,}', 
                           xy=(i, row['mean_delay']), 
                           ha='center', va='bottom', fontsize=8)
    
    plt.suptitle('Train Delays by Weather Conditions', fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout()
    plt.savefig(output_dir / 'delay_by_weather_category.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_dir / 'delay_by_weather_category.png'}")


def plot_delay_rate_by_category(delay_stats: dict, output_dir: Path):
    """Create bar plots showing significant delay rates by weather category."""
    print("Creating delay rate by category plots...")
    
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    
    categories = [
        ('temperature', 'Temperature', 'temp_category'),
        ('wind', 'Wind Speed', 'wind_category'),
        ('precipitation', 'Precipitation', 'rain_category')
    ]
    
    for ax, (key, title, col) in zip(axes, categories):
        if key in delay_stats and delay_stats[key] is not None:
            data = delay_stats[key]
            if data.empty:
                continue
            
            x = range(len(data))
            
            # Plot both delay rate and significant delay rate
            width = 0.35
            ax.bar([i - width/2 for i in x], data['delay_rate'] * 100, width,
                   label='Any Delay', color='steelblue', alpha=0.7)
            ax.bar([i + width/2 for i in x], data['significant_delay_rate'] * 100, width,
                   label='>5 min Delay', color='coral', alpha=0.7)
            
            ax.set_xticks(x)
            ax.set_xticklabels(data[col] if col in data.columns else data.iloc[:, 0],
                             rotation=45, ha='right')
            ax.set_xlabel(title)
            ax.set_ylabel('Delay Rate (%)')
            ax.set_title(f'Delay Rate by {title}')
            ax.legend(loc='upper right')
    
    plt.suptitle('Train Delay Rates by Weather Conditions', fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout()
    plt.savefig(output_dir / 'delay_rate_by_weather_category.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_dir / 'delay_rate_by_weather_category.png'}")


def plot_aggregated_trends(aggregations: dict, output_dir: Path):
    """Plot aggregated weather vs delay trends."""
    print("Creating aggregated trend plots...")
    
    plots = [
        ('temp_bins', 'temp_bin', 'Temperature (Â°C)', 'Mean Delay vs Temperature'),
        ('wind_bins', 'wind_bin', 'Wind Speed (m/s)', 'Mean Delay vs Wind Speed'),
        ('rain_bins', 'rain_bin', 'Precipitation Duration (min)', 'Mean Delay vs Precipitation'),
        ('visibility_bins', 'visibility_bin', 'Visibility (code)', 'Mean Delay vs Visibility')
    ]
    
    available = [(k, c, l, t) for k, c, l, t in plots if k in aggregations and aggregations[k] is not None]
    
    if not available:
        print("No aggregated data available for trend plots")
        return
    
    n_plots = len(available)
    fig, axes = plt.subplots(1, n_plots, figsize=(4 * n_plots, 4))
    if n_plots == 1:
        axes = [axes]
    
    for ax, (key, col, xlabel, title) in zip(axes, available):
        data = aggregations[key]
        if data.empty:
            continue
        
        # Filter to bins with enough samples
        data = data[data['count'] >= 100].copy()
        
        if len(data) < 2:
            ax.text(0.5, 0.5, 'Insufficient data', ha='center', va='center', 
                   transform=ax.transAxes)
            ax.set_xlabel(xlabel)
            ax.set_ylabel('Mean Delay (min)')
            ax.set_title(title)
            continue
        
        # Handle NaN values
        data = data.dropna(subset=[col, 'mean_delay'])
        
        ax.errorbar(data[col], data['mean_delay'], 
                   yerr=data['std_delay'].fillna(0) / np.sqrt(data['count']),
                   fmt='o-', capsize=3, capthick=1, markersize=4)
        
        ax.set_xlabel(xlabel)
        ax.set_ylabel('Mean Delay (min)')
        ax.set_title(title)
        
        # Add trend line with error handling
        if len(data) >= 3:
            try:
                x_vals = data[col].astype(float).values
                y_vals = data['mean_delay'].astype(float).values
                # Check for valid data
                if np.all(np.isfinite(x_vals)) and np.all(np.isfinite(y_vals)):
                    z = np.polyfit(x_vals, y_vals, 1)
                    p = np.poly1d(z)
                    x_line = np.linspace(x_vals.min(), x_vals.max(), 100)
                    ax.plot(x_line, p(x_line), 'r--', alpha=0.7, label='Trend')
                    ax.legend()
            except (np.linalg.LinAlgError, ValueError) as e:
                print(f"  Warning: Could not fit trend line for {key}: {e}")
    
    plt.suptitle('Weather-Delay Relationships (Aggregated)', fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout()
    plt.savefig(output_dir / 'weather_delay_trends.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_dir / 'weather_delay_trends.png'}")


def plot_extreme_weather(extreme_df: pd.DataFrame, output_dir: Path):
    """Plot extreme weather impact comparison."""
    if extreme_df is None or extreme_df.empty:
        print("No extreme weather data available")
        return
    
    print("Creating extreme weather comparison plot...")
    
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # Color coding: extreme conditions in red, normal in green
    colors = []
    for cond in extreme_df['condition']:
        if any(x in cond for x in ['Freezing', 'Strong', 'Heavy']):
            colors.append('coral')
        else:
            colors.append('lightgreen')
    
    # Mean delay comparison
    ax = axes[0]
    bars = ax.barh(extreme_df['condition'], extreme_df['mean_delay'], color=colors, alpha=0.8)
    ax.set_xlabel('Mean Arrival Delay (minutes)')
    ax.set_title('Mean Delay: Extreme vs Normal Weather')
    
    for bar, val in zip(bars, extreme_df['mean_delay']):
        ax.text(val + 0.1, bar.get_y() + bar.get_height()/2, 
               f'{val:.2f}', va='center', fontsize=9)
    
    # Delay rate comparison
    ax = axes[1]
    bars = ax.barh(extreme_df['condition'], extreme_df['delay_rate_pct'], color=colors, alpha=0.8)
    ax.set_xlabel('Delay Rate (%)')
    ax.set_title('Delay Rate: Extreme vs Normal Weather')
    
    for bar, val in zip(bars, extreme_df['delay_rate_pct']):
        ax.text(val + 0.5, bar.get_y() + bar.get_height()/2, 
               f'{val:.1f}%', va='center', fontsize=9)
    
    plt.suptitle('Impact of Extreme Weather on Train Delays', fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout()
    plt.savefig(output_dir / 'extreme_weather_impact.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_dir / 'extreme_weather_impact.png'}")


def main():
    """Main plotting pipeline."""
    print("=" * 70)
    print("WEATHER-DELAY ANALYSIS VISUALIZATION")
    print("=" * 70)
    
    if not DATA_DIR.exists():
        print(f"\nERROR: Data directory not found: {DATA_DIR}")
        print("\nPlease download the analysis results from HDFS first:")
        print(f"  hdfs dfs -get /user/s3544648/final_project/data/analysis {DATA_DIR}")
        return
    
    # Load all data
    print("\nLoading data...")
    
    corr_df = load_csv_from_spark_output(DATA_DIR / "correlations")
    if corr_df is not None:
        print(f"  Loaded correlations: {len(corr_df)} rows")
    
    delay_stats = {}
    for cat in ['temperature', 'wind', 'precipitation']:
        delay_stats[cat] = load_csv_from_spark_output(DATA_DIR / f"delay_stats_{cat}")
        if delay_stats[cat] is not None:
            print(f"  Loaded {cat} stats: {len(delay_stats[cat])} rows")
    
    extreme_df = load_csv_from_spark_output(DATA_DIR / "extreme_weather")
    if extreme_df is not None:
        print(f"  Loaded extreme weather: {len(extreme_df)} rows")
    
    aggregations = {}
    for agg_type in ['temp_bins', 'wind_bins', 'rain_bins', 'visibility_bins']:
        aggregations[agg_type] = load_csv_from_spark_output(DATA_DIR / f"aggregated_{agg_type}")
        if aggregations[agg_type] is not None:
            print(f"  Loaded {agg_type}: {len(aggregations[agg_type])} rows")
    
    # Create plots
    print("\nGenerating visualizations...")
    
    plot_correlation_heatmap(corr_df, OUTPUT_DIR)
    plot_correlation_bar(corr_df, OUTPUT_DIR)
    plot_delay_by_category(delay_stats, OUTPUT_DIR)
    plot_delay_rate_by_category(delay_stats, OUTPUT_DIR)
    plot_aggregated_trends(aggregations, OUTPUT_DIR)
    plot_extreme_weather(extreme_df, OUTPUT_DIR)
    
    print("\n" + "=" * 70)
    print("VISUALIZATION COMPLETE")
    print("=" * 70)
    print(f"\nAll plots saved to: {OUTPUT_DIR}")
    print("\nFiles generated:")
    for f in sorted(OUTPUT_DIR.glob('*.png')):
        print(f"  - {f.name}")


if __name__ == "__main__":
    main()
